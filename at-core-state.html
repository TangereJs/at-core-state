<link rel="import" href="../tangere/tangere.html" />
<link rel="import" href="../at-core-activity-queue/at-core-activity-queue.html">
<link rel="import" href="../at-core-signals/at-core-signals.html">

<dom-module id="at-core-state">
  <template>
    <style>
      :host {
        display: block;
        box-sizing: border-box;
      }
    </style>

    <at-core-signals id="coreSignals" on-state-request="_handleStateRequest" on-state-push="_handleStatePush"></at-core-signals>
    <at-core-activity-queue id="activityQueue" on-response="_handleActivityResponse" on-error="_handleActivityError"></at-core-activity-queue>

  </template>
</dom-module>
<script>
  Polymer({
    is: "at-core-state",
    properties: {

    },

    created: function () {
      //
      // cached data should hold responses for named requests
      //
      if (this._state == undefined) {
        this._state = {};
      }

    },

    ready: function () {

    },

    _handleStateRequest: function (event) {
      var stateRequest = event.detail;

      stateRequest.name = stateRequest.url;

      var cachedState = this._state[stateRequest.name];

      var currentTimeStamp = Date.now();
      var milliSecondsPassed = 0;

      // If the request is cached and answered -> calculate milliSecondsPassed
      if (cachedState != undefined && cachedState.status == "Answered") {
        milliSecondsPassed = currentTimeStamp - cachedState.cacheTimeStamp;;
      }

      // If the request is not cached -> send a new request, add it to cache and set request.Status to "Sent"
      if (cachedState == undefined) {
        this._cacheStateRequest(stateRequest);
        this.$.activityQueue.addRequest(stateRequest);
      }

      // If the request is cached and unanswered -> do not send a new request
      if (cachedState != undefined && cachedState.status == "Sent") {
        return;

      }

      // If the request is cached and answered within last 5 seconds -> return cached response
      if (cachedState != undefined && milliSecondsPassed < 5000 && cachedState.status == "Answered") {
        var response = this._state[stateRequest.name];

        if (response.errorText != undefined) {
        // If the cached state is an error -> signal 'state-error'
          this.async(function () {
            Polymer.signal('state-error', response);
          });
        } else {
          // If the cached state is a valid response -> signal 'state-update'
          this.async(function () {
            Polymer.signal('state-update', response);
          });
        }

        return;
      }

      // If the request is cached and not answered within last 5 seconds -> clear cache and send a new request
      if (cachedState != undefined && milliSecondsPassed > 5000 && cachedState.status == "Answered") {
        this._clearStateRequestFromCache(stateRequest.name);
        this._cacheStateRequest(stateRequest);
        this.$.activityQueue.addRequest(stateRequest);
      }

    },

    _cacheStateRequest: function (stateRequest) {
      var existing = this._state[stateRequest.name];

      // Cache this stateRequest if it doesn't exist.
      // When a request is created and sent - set it's status to "Sent"
      if (!existing) {
        this._state[stateRequest.name] = {
          status: "Sent",
        };
      }
    },

    _clearStateRequestFromCache: function (stateRequestName) {
      var existing = this._state[stateRequestName];

      if (existing) {
        delete this._state[stateRequestName];
      }
    },

    _handleActivityResponse: function (event) {
      var response = event.detail;

      var responseTimeStamp = Math.floor(Date.now());

      var existing = this._state[response.name];

      // When activity response is received, change existing cache state's status to "Answered" and set it's data and timestamp values.
      if (existing.status == "Sent") {
        this._state[response.name] = {
          version: 1,
          data: response,
          status: "Answered",
          cacheTimeStamp: responseTimeStamp
        };
        existing = this._state[response.name];

      } else {
        existing.version += 1;
        existing.data = response;
        existing.status = "Answered";

      }

      Polymer.signal('state-update', existing);
    },

    _handleActivityError: function (e) {
      var stateError = e.detail;

      stateError.error.handler.handled = true;

      var existing = this._state[stateError.name];

      // If the state doesn't exist -> cache state error
      // If the state exists and has status equal to "Sent" -> set status to "Error" and provide error details
      if (!existing || existing.status == "Sent") {

        // handle errors where ErrorCode !=0 or where ErrorCode == 0
        if (stateError.error.response.ErrorCode != 0 || stateError.error.response.ErrorCode == 0) {
          this._cacheStateError(stateError);
          var response = this._state[stateError.name];
          this.async(function () {
            Polymer.signal('state-error', response);
          });

        }

      }

    },

    // _cacheStateError is used to cache state errors from _handleActivityError
    _cacheStateError: function (stateError) {
      var existing = this._state[stateError.name];

      if (existing == undefined || existing.status == "Sent") {

        this._state[stateError.name] = {
          name: stateError.name,
          errorCode: stateError.error.response.ErrorCode,
          errorText: stateError.error.response.Data.ErrorText,
          status: "Answered",
          cacheTimeStamp: Math.floor(Date.now())
        };

      }
    },

    // _handleStatePush is used to cache data from 'state-push'
    _handleStatePush: function (event) {
      var state = event.detail;

      state.name = state.url;

      var existing = this._state[state.name];

      // Clear cache if 5 seconds have passed
      var currentTimeStamp = Date.now();
      var milliSecondsPassed = 0;

      // If the request is cached and answered -> calculate milliSecondsPassed
      if (existing != undefined && existing.status == "Answered") {
        milliSecondsPassed = currentTimeStamp - existing.cacheTimeStamp;
      }

      // If there is no state with such name, cache this state and signal an update
      if (!existing) {
        this._cacheStatePush(state);
        var response = this._state[state.name];
        this.async(function () {
          Polymer.signal('state-update', response);
        });
      }

      // If there is cached state with status "Answered" that is requested within 5 seconds -> don't signal an update
      if (existing != undefined && existing.status == "Answered" && milliSecondsPassed < 5000) {
        return;
      }

      // If 'state-push' is issued after 5 seconds of last cached state -> clear the old one from cache, add a new one and signal an update
      if (existing != undefined && existing.status == "Answered" && milliSecondsPassed > 5000) {
        this._clearStateRequestFromCache(state.name);
        this._cacheStatePush(state);
        var response = this._state[state.name];
        this.async(function () {
          Polymer.signal('state-update', response);
        });
      }
    },

    _cacheStatePush: function (statePush) {
      var existing = this._state[statePush.name];

      // Check if state is cached or if it has status equal to "Sent"
      // A state has status "Sent" when it's not responded to yet
      if (existing == undefined || existing.status == "Sent") {
        // If a state doesn't exist in the chache -> add it
        // Set initial version -> set data -> set status to "Answered" -> set timestamp
        // Setting the status to "Answered" mimics the requests that have been answered
        this._state[statePush.name] = {
          version: 1,
          data: statePush,
          status: "Answered",
          cacheTimeStamp: Math.floor(Date.now())
        };
      }
    },

  });
</script>
