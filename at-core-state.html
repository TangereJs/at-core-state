<link rel="import" href="../tangere/tangere.html" />
<link rel="import" href="../at-core-activity-queue/at-core-activity-queue.html">
<link rel="import" href="../at-core-signals/at-core-signals.html">

<dom-module id="at-core-state">
  <template>
    <style>
      :host {
        display: block;
        box-sizing: border-box;
      }
    </style>

    <at-core-signals id="coreSignals" on-state-request="_handleStateRequest" on-state-push="_handleStatePush"></at-core-signals>
    <at-core-activity-queue id="activityQueue" on-response="_handleActivityResponse" on-error="_handleActivityError"></at-core-activity-queue>

  </template>
</dom-module>
<script>
  Polymer({
    is: "at-core-state",
    properties: {

    },

    created: function () {
      //
      // cached data should hold responses for named requests
      //
      if (this._state == undefined) {
        this._state = {};
        Tangere._state = this._state;
      }

    },

    ready: function () {

    },

    _cacheStateRequest: function (stateRequest) {
      if (!this._stateExists(stateRequest.name)) {
        this._state[stateRequest.name] = {
          status: "Sent",
        };
      }
    },


    _cacheStateError: function (stateError) {
      var existing = this._state[stateError.name];

      if (existing == undefined || existing.status == "Sent") {

        this._state[stateError.name] = {
          name: stateError.name,
          errorCode: stateError.error.response.ErrorCode,
          errorText: stateError.error.response.Data.ErrorText,
          status: "Answered",
          cacheTimeStamp: Math.floor(Date.now())
        };

      }
    },

    _clearStateFromCache: function (stateName) {
      console.log("clear from cache: " + stateName);
      if (this._stateExists(stateName)) {
        delete this._state[stateName];
      }
    },

    _stateExists: function (stateName) {
      var existing = this._state[stateName];

      if (existing) {
        return true;
      } else {
        return false;
      }
    },

    _signalUpdate: function (stateName) {
      var state = this._state[stateName];
      //console.log("state cached answer " + stateName);     

      if (state.status == "Answered") {
        this.async(function () {
          //console.log("state answer async " + stateName);
          Polymer.signal('state-update', state);
        });
      }
    },

    _queueRequest: function (stateRequest) {
      //console.log("_queueRequest");

      // *TODO* detect if request is already sent and pending answer - in that case new request should be ignored
      this._cacheStateRequest(stateRequest);
      this.$.activityQueue.addRequest(stateRequest);
    },

    _handleStateRequest: function (event) {

      var stateRequest = event.detail;
      stateRequest.name = stateRequest.url;
      //console.log("state request " + stateRequest.name);

      // default cache duration in milliseconds
      var cacheDuration = 10000;

      // If maxAge is 0 -> always clear old state from cache if existing, cache and send a new one
      if (stateRequest.maxAge === 0) {
        if (this._stateExists(stateRequest.name)) {
          var existing = this._state[stateRequest.name];

          if (existing.status == 'Sent') {
            return;
          }

          this._clearStateFromCache(stateRequest.name);
        }

        this._queueRequest(stateRequest);
        return;
      }

      // If maxAge is false -> always return cached state if existing. Otherwise, cache and send a new one
      if (stateRequest.maxAge === false) {
        if (this._stateExists(stateRequest.name)) {
          this._signalUpdate(stateRequest.name);
          return;
        }

        this._queueRequest(stateRequest);
        return;
      }

      // If maxAge == undefined, use default cacheDuration
      if (stateRequest.maxAge !== 0 && stateRequest.maxAge !== false && stateRequest.maxAge !== undefined) {
        cacheDuration = stateRequest.maxAge * 1000;
      }

      var cachedState = this._state[stateRequest.name];
      
      var currentTimeStamp = Date.now();
      var milliSecondsPassed = 0;

      // If the request is cached and answered -> calculate milliSecondsPassed
      if (cachedState != undefined && cachedState.status == "Answered") {
        milliSecondsPassed = currentTimeStamp - cachedState.cacheTimeStamp;;
      }

      // If the request is not cached -> send a new request, add it to cache and set request.Status to "Sent"
      if (cachedState == undefined) {
        this._queueRequest(stateRequest);
        return;
      }

      // If the request is cached and unanswered -> do not send a new request, wait for answser
      if (cachedState.status == "Sent") {
        return;
      }

      if (cachedState.status != "Answered") debugger; // are there any other status values then Answered and Sent ?

      // If the request is cached and requested within last cacheDurtion -> return cached response
      if ( milliSecondsPassed <= cacheDuration) {
        this._signalUpdate(stateRequest.name);
        return;
      } else  {
        // If the request cache is expired  -> clear cache and send a new request
        this._clearStateFromCache(stateRequest.name);
        this._queueRequest(stateRequest);
        return;
      }
    },

    _handleStatePush: function (event) {

      var statePush = event.detail;
      var cacheDuration = 10000;

      statePush.name = statePush.url;
      //console.log("state push " + statePush.name);

      
      // Set  version -> set data -> set status to "Answered" -> set timestamp
      // Setting the status to "Answered" mimics the requests that have been answered
      this._state[statePush.name] = {
        version: Math.floor(Date.now()),
        data: statePush,
        status: "Answered",
        cacheTimeStamp: Math.floor(Date.now())
      };

      this._signalUpdate(statePush.name);

    },

    // handle activity error should send state-update signal with error
    _handleActivityError: function (e) {
      var stateError = e.detail;
      stateError.error.handler.handled = true;
      var existing = this._stateExists[stateError.name];

      // when disableErrorCodeHandler is true -> cache a response and signal 'state-update'
      if (existing != undefined && existing.disableErrorCodeHandler == true) {
        if (stateError.error.response.ErrorCode != 0 || stateError.error.response.ErrorCode == 0) {
          this._cacheStateError(stateError);
          this._signalUpdate(stateError.name);
        }
      } else {
        // disabledErrorCodeHandler is false -> do not cache and do not signal 'state-error'
        return;
      }
    },

    _handleActivityResponse: function (event) {
      console.log("Handle activity response.");
      var response = event.detail;
      var responseTimeStamp = Math.floor(Date.now());
      var existing = this._state[response.name];

      // When activity response is received, change existing cache state's status to "Answered" and set it's data and timestamp values.
      // Version is now calculated from timestamp instead of being incremented
      if (existing.status == "Sent") {
        this._state[response.name] = {
          version: Math.floor(Date.now()),
          data: response,
          status: "Answered",
          cacheTimeStamp: responseTimeStamp,
        };
        existing = this._state[response.name];

      } else {
        existing.version = Math.floor(Date.now());
        existing.data = response;
        existing.status = "Answered";
      }

      //console.log("state receive " + response.name);
      Polymer.signal('state-update', existing);
    },

  });
</script>
