<link rel="import" href="../tangere/tangere.html" />
<link rel="import" href="../at-core-activity-queue/at-core-activity-queue.html">
<link rel="import" href="../at-core-signals/at-core-signals.html">

<dom-module id="at-core-state">
  <template>
    <style>
      :host {
        display: block;
        box-sizing: border-box;
      }
    </style>
    
    <at-core-signals id="coreSignals" on-state-request="_handleStateRequest" on-state-push="_handleStatePush"></at-core-signals>
    <at-core-activity-queue id="activityQueue" on-response="_handleActivityResponse" on-error="_handleActivityError"></at-core-activity-queue>
    
  </template>
</dom-module>
<script>
  Polymer({
    is: "at-core-state",
    properties: {

    },
    
    created: function() {
      // 
      // cached data should hold responses for named requests
      // 
      if (this._state == undefined) {
        this._state = {};
      }

    },

    ready: function() {

    },

    _handleStateRequest: function(event) {
      var stateRequest = event.detail;

      var cachedState = this._state[stateRequest.name];

      var currentTimeStamp = Math.floor(Date.now());
      var secondsPassed = 0;

      // If the request is cached and answered -> calculate secondsPassed
      if (cachedState != undefined && cachedState.status == "Answered") {
        secondsPassed = Math.floor((currentTimeStamp - cachedState.cacheTimeStamp) / 1000);
      }
      
      // If the request is not cached -> send a new request, add it to cache and set request.Status to "Sent"
      if (cachedState == undefined) {
        this._cacheStateRequest(stateRequest);
        this.$.activityQueue.addRequest(stateRequest);
      }

      // If the request is cached and unanswered -> do not send a new request
      if (cachedState != undefined && cachedState.status == "Sent") {
        return;
      }

      // If the request is cached and answered within last 5 seconds -> return cached response
      if (cachedState != undefined && secondsPassed < 5 && cachedState.status == "Answered") {
        var response = this._state[stateRequest.name];
        this.async(function () {
          Polymer.signal('state-update', response);
        });

        return
      }

      // If the request is cached and not answered within last 5 seconds -> clear cache and send a new request
      if (cachedState != undefined && secondsPassed > 5 && cachedState.status == "Answered") {
        this._clearStateRequestFromCache(stateRequest);
        this._cacheStateRequest(stateRequest);
        this.$.activityQueue.addRequest(stateRequest);
      }

    },

    _cacheStateRequest: function (stateRequest) {
      var existing = this._state[stateRequest.name];

      if (!existing) {
        this._state[stateRequest.name] = {
          status: "Sent",
        };
      }
    },

    _clearStateRequestFromCache: function (stateRequest) {
      var existing = this._state[stateRequest.name];

      if (existing) {
        delete this._state[stateRequest.name];
      }
    },

    _handleActivityResponse: function(event) {
      var response = event.detail;

      var responseTimeStamp = Math.floor(Date.now());
      
      var existing = this._state[response.name];
      if (existing.status == "Sent") {
        this._state[response.name] = {
          version: 1,
          data: response,
          status: "Answered",
          cacheTimeStamp: responseTimeStamp
        };
        existing = this._state[response.name];

      } else {
        existing.version += 1;
        existing.data = response;
        existing.status = "Answered";
      }

      Polymer.signal('state-update', existing);
    },
    
    _handleActivityError: function(error) {
      debugger
    },

    _handleStatePush: function(event) {
      var state = event.detail;

      var existing = this._state[state.name];
      if (!existing) {
        existing = this._state[state.name] = {
          version: 1,
          data: state
        };
      
      } else {
        existing.version += 1;
        existing.data = state;
      }

      this.async(function() {
        Polymer.signal('state-update', existing);
      });
    },

  });
</script>
